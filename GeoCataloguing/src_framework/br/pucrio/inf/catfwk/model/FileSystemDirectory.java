/* Generated by Together */

package br.pucrio.inf.catfwk.model;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Set;

import javax.xml.parsers.ParserConfigurationException;

import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

import br.pucrio.inf.lib.util.Utils;

/**
 * @author Luiz André
 * @version 1.0
 * @since 1.0
 * @alias FileSystemDirectory*/
public class FileSystemDirectory extends Repository {

	/**
	 * 
	 */
	private static final long serialVersionUID = 800583847091139314L;

	public FileSystemDirectory(String directory) {
		super(directory);
	}

	/**
	 * @version 1.0
	 * @since 1.0
	 * @return lista de URI's contidas no diretório
	 */
	public String[] listURI() throws IOException {
		if (getUrl() == null)
			throw new IOException("name: <" + getUrl() + "> is not a directory");
		File directory = new File(getUrl());
		if (!directory.isDirectory())
			throw new IOException("name: <" + getUrl() + "> is not a directory");
		else if (!directory.canRead())
			throw new IOException("Can't read directory: <" + getUrl() + ">");

		/*
		 * Listar arquivos do diretório
		 */
		File[] files = directory.listFiles();
		if (files != null) {
			/*
			 * Recuperar extensões de arquivos cujos conteúdos sejam capazes de
			 * serem lidos.
			 */
			Set extensions = getParsers().keySet();
			ArrayList knownFiles = new ArrayList();
			String extension = null;
			/*
			 * Para cada arquivo da lista armazená-lo na lista de objetos
			 * conhecidos se houver reader capaz de decodificar seu conteúdo
			 */
			for (int i = 0; i < files.length; i++) {
				extension = Utils.getExtension(files[i]);
				/*
				 * Se houver reader capaz de decodificar arquivos com a extensão
				 * igual a do arquivo corrente, armazenar arquivo na lista de
				 * arquivos conhecidos
				 */
				if (extension != null && extensions.contains(extension)) {
					knownFiles.add(files[i].getPath());
				}
			}
			if (knownFiles.isEmpty())
				return null;
			// String[] result = new String[knownFiles.size()];
			// for (int i = 0; i < result.length; i++) {
			// result[i] = (String) knownFiles.get(i);
			// }
			knownFiles.trimToSize();
			return (String[]) knownFiles.toArray(new String[0]);
		}
		return null;
	}

	/**
	 * Busca os metadados contidos no meio digital de armazenamento da imagem.
	 * 
	 * @version 1.0
	 * @since 1.0
	 * @param uri
	 *            URI de localização da imagem
	 * @return objeto a ser catalogado na
	 */
	public DatasetDescription getDescription(Object obj)
			throws InvalidDatasetDescException, ParserConfigurationException,
			SAXException, IOException, NumberFormatException {
		String uri = (String) obj;
		DatasetDescription datasetDescription = null;
		Parser parser = null;
		File file = null;
		if (uri != null) {
			file = new File(uri);
			if (file.canRead()) {
				if (getParsers() != null) {
					/*
					 * Recuperar o leitor correspondente ao formato de
					 * armazenamento do objeto
					 */
					parser = (Parser) getParsers()
							.get(Utils.getExtension(file));
					if (parser != null)
						/*
						 * Decodificar conteúdo do objeto e armazená-lo na
						 * estrutura de catalogação
						 */
						parser.parse(new InputSource(uri));
				}
				if (getBuilder() != null) {
					/*
					 * Recuperar estrutura de catalogação do objeto
					 */
					datasetDescription = getBuilder().getDatasetDescription();
					datasetDescription.setUri(uri);
				}
			} else {
				throw new IOException("Can't read filename: " + uri);
			}
		} else
			throw new IOException("Can't read filename: " + uri);
		return datasetDescription;
	}
}
